# 设计模式学习 #

----------

## 抽象工厂模式*
> 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。

### 角色
有多个生产者（产品级别1，2），多种产品（产品族A，B），相互排列组合形成多种具体的产品（A1,B1,A2,B2）。

## 适配器模式
> 将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

### 角色
- Target目标角色
- Adaptee源角色
- Adapter适配器角色

### 适用场合
系统的数据和行为都正确，只是接口不符合时，考虑用适配器。目的是控制范围之外的一个原有对象与某个接口匹配。

## 建造者模式
> 将一个复杂对象的构建与它的表示分离，是的同样的构建过程可以创建不同的表示。

### 一般的建造者模式
- Product产品类
- Builder抽象建造者
- ConcreteBuilder具体建造者
- Director导演类

### 构造器
- javabeans模式在构造对象时，很可能出现不一致的现象
- 在构造对象参数时，如果出现错误很难定位
- 对象的属性只有在build时指定，之后类内不提供setter方法，保证线程安全

## 命令模式*
> 将一个请求封装成一个对象，从而让你使用不同的请求吧客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

### 角色
- Receiver接受者角色
- Command命令角色
- Invoker调用者角色

## 观察者模式
> 定义对象间一种一对多的依赖关系，使得当每个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

### 角色
- Subject被观察者
- Observer观察者
- ConcreteSubje具体被观察者
- ConcreteObserver具体观察者

## 简单工厂模式
> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法时一个类的实例化延迟到其子类。

### 简单工厂模式
- Creator生产者
- Product抽象产品类
- ConcreteProduct具体产品类

### 延迟工厂模式
定义一个缓存容器，如果请求对象未被创建则新建；如果请求对象已被创建则返回已经创建出的实例。

## 单例模式
> 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

要注意线程同步问题，保证线程安全。

## 策略模式
> 定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。

### 角色
- Context封装角色
- Strategy抽象策略角色
- ConcreteStrategy具体策略角色

### 适用场合
代替多重条件语句

## 模板方法模式
> 定义一个操作中的算法框架，而将一些步骤延迟到子类中。是的子类可以不改变一个算法的结构可以重定义该算法的某些特定步骤。

### 我的理解
算法的整体流程是已经制定的模板，由抽象类来定义，即算法步骤的先后顺序。而具体的每一步骤交给具体类来实现。

### 角色
- Template抽象模板类
- ConcreteTemplate具体模板类

## 代理模式
> 为其他对象提供一种代理以控制这个对象的访问。

### 角色
- Subject抽象主题角色
- RealSubject具体主题角色
- Proxy代理主题角色 
